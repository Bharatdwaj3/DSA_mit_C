#include <stdio.h>
#include <stdlib.h>

// Structure for linked list node
struct ListNode {
    int data;
    struct ListNode *next;
};

// Structure for BST node
struct BSTNode {
    int data;
    struct BSTNode *left;
    struct BSTNode *right;
};

// Function to create a new linked list node
struct ListNode* createListNode(int data) {
    struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to create a new BST node
struct BSTNode* createBSTNode(int data) {
    struct BSTNode* newNode = (struct BSTNode*)malloc(sizeof(struct BSTNode));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to insert into BST
struct BSTNode* insertBST(struct BSTNode* root, int data) {
    if (root == NULL) {
        return createBSTNode(data);
    }
    if (data < root->data) {
        root->left = insertBST(root->left, data);
    } else {
        root->right = insertBST(root->right, data);
    }
    return root;
}

// Function to insert at beginning of linked list
void insertStart(struct ListNode** head, int data) {
    struct ListNode* newNode = createListNode(data);
    newNode->next = *head;
    *head = newNode;
}

// Function to print linked list
void printList(struct ListNode* head) {
    while (head != NULL) {
        printf("%d ", head->data);
        head = head->next;
    }
    printf("\n");
}

// 1. Function to print alternate nodes of a linked list
void printAlternateNodes(struct ListNode* head) {
    printf("Alternate nodes: ");
    int position = 0;
    while (head != NULL) {
        if (position % 2 == 0) {  // Print nodes at even positions (0, 2, 4, ...)
            printf("%d ", head->data);
        }
        head = head->next;
        position++;
    }
    printf("\n");
}

// 2. Function to count nodes in BST less than given key
int countNodesLessThanKey(struct BSTNode* root, int key) {
    if (root == NULL) {
        return 0;
    }
    
    if (root->data < key) {
        // Current node is less than key, so count it and check both subtrees
        return 1 + countNodesLessThanKey(root->left, key) + countNodesLessThanKey(root->right, key);
    } else {
        // Current node is >= key, so only check left subtree
        return countNodesLessThanKey(root->left, key);
    }
}

// 3. Function to find successor in BST
struct BSTNode* findMin(struct BSTNode* root) {
    while (root && root->left) {
        root = root->left;
    }
    return root;
}

struct BSTNode* findSuccessor(struct BSTNode* root, int key) {
    struct BSTNode* successor = NULL;
    struct BSTNode* current = root;
    
    while (current != NULL) {
        if (key < current->data) {
            successor = current;  // Potential successor
            current = current->left;
        } else if (key > current->data) {
            current = current->right;
        } else {
            // Found the node with the key
            if (current->right != NULL) {
                // If right subtree exists, successor is the leftmost node in right subtree
                return findMin(current->right);
            }
            break;
        }
    }
    
    return successor;
}

// 4. Function to print sum of two linked lists (position-wise addition)
void printSumOfTwoLists(struct ListNode* list1, struct ListNode* list2) {
    printf("Position-wise sum: ");
    while (list1 != NULL || list2 != NULL) {
        int sum = 0;
        if (list1 != NULL) {
            sum += list1->data;
            list1 = list1->next;
        }
        if (list2 != NULL) {
            sum += list2->data;
            list2 = list2->next;
        }
        printf("%d ", sum);
    }
    printf("\n");
}

// Graph structure for vertex traversal
struct Graph {
    int vertices;
    int** adjMatrix;
};

// Function to create a graph
struct Graph* createGraph(int vertices) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->vertices = vertices;
    graph->adjMatrix = (int**)malloc(vertices * sizeof(int*));
    
    for (int i = 0; i < vertices; i++) {
        graph->adjMatrix[i] = (int*)calloc(vertices, sizeof(int));
    }
    
    return graph;
}

// Function to add edge to graph
void addEdge(struct Graph* graph, int src, int dest) {
    graph->adjMatrix[src][dest] = 1;
    graph->adjMatrix[dest][src] = 1; // For undirected graph
}

// 5. DFS to print all reachable vertices from source
void DFS(struct Graph* graph, int vertex, int* visited) {
    visited[vertex] = 1;
    printf("%d ", vertex);
    
    for (int i = 0; i < graph->vertices; i++) {
        if (graph->adjMatrix[vertex][i] && !visited[i]) {
            DFS(graph, i, visited);
        }
    }
}

void printAllReachableVertices(struct Graph* graph, int src) {
    int* visited = (int*)calloc(graph->vertices, sizeof(int));
    printf("All vertices reachable from %d: ", src);
    DFS(graph, src, visited);
    printf("\n");
    free(visited);
}

// Test function
int main() {
    printf("=== Testing Linked List Functions ===\n");
    
    // Create first linked list: 1->2->3->4->5
    struct ListNode* list1 = NULL;
    insertStart(&list1, 5);
    insertStart(&list1, 4);
    insertStart(&list1, 3);
    insertStart(&list1, 2);
    insertStart(&list1, 1);
    
    printf("List 1: ");
    printList(list1);
    printAlternateNodes(list1);
    
    // Create second linked list: 6->7->8
    struct ListNode* list2 = NULL;
    insertStart(&list2, 8);
    insertStart(&list2, 7);
    insertStart(&list2, 6);
    
    printf("List 2: ");
    printList(list2);
    
    printSumOfTwoLists(list1, list2);
    
    printf("\n=== Testing BST Functions ===\n");
    
    // Create BST: 50, 30, 70, 20, 40, 60, 80
    struct BSTNode* root = NULL;
    root = insertBST(root, 50);
    root = insertBST(root, 30);
    root = insertBST(root, 70);
    root = insertBST(root, 20);
    root = insertBST(root, 40);
    root = insertBST(root, 60);
    root = insertBST(root, 80);
    
    int key = 45;
    printf("Number of nodes less than %d: %d\n", key, countNodesLessThanKey(root, key));
    
    key = 30;
    struct BSTNode* successor = findSuccessor(root, key);
    if (successor) {
        printf("Successor of %d is: %d\n", key, successor->data);
    } else {
        printf("No successor found for %d\n", key);
    }
    
    printf("\n=== Testing Graph Functions ===\n");
    
    // Create a simple graph with 5 vertices
    struct Graph* graph = createGraph(5);
    addEdge(graph, 0, 1);
    addEdge(graph, 0, 2);
    addEdge(graph, 1, 3);
    addEdge(graph, 2, 4);
    
    printAllReachableVertices(graph, 0);
    
    return 0;
